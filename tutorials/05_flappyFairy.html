<!doctype html>
<meta charset="utf-8">
<title>Flappy Fairy</title>
<body>
<!-- Import the Ga game engine files -->
<script src="../ga.js"></script>
<script src="../plugins.js"></script>
<script>

//Create a new GA instance, and start it.
//Pre-load images in the array.
var g = ga(
  910, 512, setupTitleScreen,
  [
    "images/flappyFairy/flappyFairy.json"
  ]
);
g.start();

//Enable fullscreen mode using `enableFullscreen`.
//Fullscreen mode will be activated as soon as the 
//user clicks or touches the canvas.
//You can supply an optional list of ascii keycodes for keys that
//will exit fullscreen mode. In this example you can exit fullscreen
//mode by pressing lowercase `x` (88) or uppercase `X` (120) on 
//the keyboard. If you leave these arguments out, the default `esc`
//key will do the trick.
g.enableFullscreen(88, 120);

//Declare any variables shared between functions
var pointer, canvas, fairy, sky, blocks, 
    title, goButton, finish, dust, dustFrames;

//The `setup` function will run only once.
//Use it for initialization tasks
function setupTitleScreen() {

  //Make the sky background
  sky = g.tilingSprite(
    g.canvas.width, 
    g.canvas.height,
    "sky.png" 
  );

  //Create the title sprite
  title = g.sprite("title.png");

  //Center the title
  g.stage.putCenter(title, 0, -70);

  //Create the play button
  goButton = g.button([
    "up.png",
    "over.png",
    "down.png"
  ]);

  //Center the play button
  g.stage.putCenter(goButton, 0, 150);

  //Make the play button's `press` action
  //start the game when the button is pressed.
  goButton.release = function(){
    g.state = setupGame;
  };

  //Start the `playTitleScreen` state.
  g.state = playTitleScreen;

}

function playTitleScreen() {
  
  //Make the sky background scroll by shifting the `tileX`
  //of the `sky` tiling sprite.
  sky.tileX -= 1;

}

function setupGame() {

  //Make the title and play button invisible.
  title.visible = false;
  goButton.visible = false;

  //Disable the play button so that it can't be pressed
  //by setting its `enabled` property to `false`.
  goButton.enabled = false;

  //Make the world
  //Create a `group` for all the blocks
  blocks = g.group();

  //What should the initial size of the gap be between the pillars?
  var gapSize = 4;

  //How many pillars?
  var numberOfPillars = 15;

  //Loop 15 times to make 15 pillars
  for (var i = 0; i < numberOfPillars; i++) {

    //Randomly place the gap somewhere inside the pillar
    var startGapNumber = g.randomInt(0, 8 - gapSize); 

    //Reduce the `gapSize` by one after every fifth pillar. This is
    //what makes gaps gradually become narrower
    if (i > 0 && i % 5 === 0) gapSize -= 1; 

    //Create a block if it's not within the range of numbers
    //occupied by the gap
    for (var j = 0; j < 8; j++) {
      if (j < startGapNumber || j > startGapNumber + gapSize - 1) {
        var block = g.sprite("greenBlock.png");
        blocks.addChild(block);

        //Space each pillar 384 pixels apart. The first pillar will be
        //placed at an x position of 512
        block.x = (i * 384) + 512;
        block.y = j * 64;
      }
    }

    //After the pillars have been created, add the finish image
    //right at the end
    if (i === numberOfPillars - 1) {
      finish = g.sprite("finish.png");
      blocks.addChild(finish);
      finish.x = (i * 384) + 896;
      finish.y = 192;
    }
  }

  //Make the fairy 
  var fairyFrames = [
    "0.png", 
    "1.png", 
    "2.png"
  ];
  fairy = g.sprite(fairyFrames);
  fairy.fps = 24;
  fairy.setPosition(232, 32);
  fairy.vy = 0;
  fairy.oldVy = 0;

  //Create the frames array for the fairy dust images
  //that trail the fairy 
  dustFrames = [
    "pink.png",
    "yellow.png",
    "green.png",
    "violet.png"
  ];

  //Create the emitter
  dust = g.emitter(
    300,                                   //The interval
    function() {
      return g.particleEffect(             //The function
        fairy.x + 8,                       //x position
        fairy.y + fairy.halfHeight + 8,    //y position
        function() {                       //Particle sprite
          return g.sprite(dustFrames)
        },          
        3,                                 //Number of particles
        0,                                 //Gravity
        true,                              //Random spacing
        2.4, 3.6,                          //Min/max angle
        12, 18,                            //Min/max size
        1, 2,                              //Min/max speed
        0.005, 0.01,                       //Min/max scale speed
        0.005, 0.01,                       //Min/max alpha speed
        0.05, 0.1                          //Min/max rotation speed
      );
    }
  );

  //Make the particle stream start playing when the game starts
  dust.play();

  //Make the pointer and increase the fairy's 
  //vertical velocity when it's tapped
  g.pointer.tap = function() {
    fairy.vy += 1.5;
  };  

  //set the game state to `play`
  g.state = play;
}

//The `play` state
function play() {

  //Make the sky background scroll by shifting the `tileX`
  //of the `sky` tiling sprite
  sky.tileX -= 1;

  //Move the blocks 2 pixels to the left each frame.
  //This will just happen while the finish image is off-screen.
  //As soon as the finish image scrolls into view, the blocks
  //container will stop moving
  if (finish.gx > 256) {
    blocks.x -= 2;
  }

  //Add gravity to the fairy
  fairy.vy += -0.05;
  fairy.y -= fairy.vy;

  //Decide whether or not the fairy should flap her wings 
  //If she's starting to go up, make her flap her wings and emit fairy dust
  if (fairy.vy > fairy.oldVy) {
    if(!fairy.playing) {
      fairy.play();
      if (fairy.visible && !dust.playing) dust.play();
    }
  }

  //If she's staring to go down, stop flapping her wings, show the first frame 
  //and stop the fairy dust
  if (fairy.vy < 0 && fairy.oldVy > 0) {
    if (fairy.playing) fairy.stop();
    fairy.show(0);
    if (dust.playing) dust.stop();
  }

  //Store the fairy's current vy so we can use it
  //to find out if the fairy has changed direction
  //in the next frame. (You have to do this as the last step)
  fairy.oldVy = fairy.vy;

  //Keep the fairy contained inside the stage and 
  //neutralize her velocity if she hits the top or bottom boundary
  var fairyVsStage = g.contain(fairy, g.stage.localBounds);
  if (fairyVsStage === "bottom" || fairyVsStage === "top") {
    fairy.vy = 0;  
  }

  //Loop through all the blocks and check for a collision between
  //each block and the fairy. (`some` will quit the loop as soon as
  //`hitTestRectangle` returns `true`). Set `hitTestRectangle`s third argument
  //to `true` to use the sprites' global coordinates
  var fairyVsBlock = blocks.children.some(function(block){
    return g.hitTestRectangle(fairy, block, true);  
  });

  //If there's a collision and the fairy is currently visible,
  //create the explosion effect and reset the game after
  //a three second delay

  if (fairyVsBlock && fairy.visible) {

    //Make the fairy invisible
    fairy.visible = false;

    //Create a fairy dust explosion
    g.particleEffect(
      fairy.centerX, fairy.centerY, //x and y position
      function() {                  //Particle sprite
        return g.sprite(dustFrames);
      },     
      20,                           //Number of particles
      0,                            //Gravity
      false,                        //Random spacing
      0, 6.28,                      //Min/max angle
      16, 32,                       //Min/max size
      1, 3                          //Min/max speed
    );
    
    //Stop the dust emitter that's trailing the fairy
    dust.stop();

    //Wait 3 seconds and then reset the game
    g.wait(3000, reset);
  }

  //Alternatively, you can achieve the same collision effect
  //using the higher level universal `hit` function
  /*
  //Check for a collision between the fairy and the blocks
  var fairyVsBlock = g.hit(

    //arguments: sprite, array, react, bounce, global 
    fairy, blocks.children, false, false, true,

    //collision function
    function(){
      if (fairy.visible) {

        //Make the fairy invisible
        fairy.visible = false;

        //Create a fairy dust explosion
        g.particleEffect(
          fairy.centerX, fairy.centerY, //x and y position
          function() {                  //Particle sprite
            return g.sprite(dustFrames)
          },     
          20,                           //Number of particles
          0,                            //Gravity
          false,                        //Random spacing
          0, 6.28,                      //Min/max angle
          16, 32,                       //Min/max size
          1, 3                          //Min/max speed
        );
        
        //Stop the dust emitter
        dust.stop();

        //Wait 3 seconds and then reset the game
        g.wait(3000, reset);
      }
    }
  );
  */

}

function reset() {

  //Reset the game if the fairy hits a block
  fairy.visible = true;
  fairy.y = 32;
  dust.play();
  blocks.x = 0;  
}

</script>
</body>



